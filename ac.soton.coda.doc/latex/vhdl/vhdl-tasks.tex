\section{Tasks}
\label{sec:vhdl-tasks}

\subsection{Translating CODA models into VHDL}
\label{sec:transl-coda-2-vxmi}

For a component \code{C}, its corresponding model contains two design units.
\begin{enumerate}
\item The first design unit contains the generated context items and the  entity declaration.
\item The second design unit contains the architecture body of the declared entity.
\end{enumerate}

\subsubsection{Context Items}
\label{sec:vhdl-context-items}

By default, the context items are generated for each component can be seen in Table \ref{tab:vhdl-ctx-items}.
\begin{table}[!htbp]
  \centering
  \begin{tabular}{|p{0.3\textwidth}|p{0.6\textwidth}|}
    \hline
    Source & Generated \\
    \hline
    For component \code{C} & 
                                  \begin{VHDLcode}
                                    \VHDLLIBRARY{} ieee;\\
                                    \VHDLUSE{} ieee.std\_logic\_1164.all;\\
                                    \VHDLUSE{} ieee.std\_logic\_unsigned.all;
                                  \end{VHDLcode} \\
    \hline
  \end{tabular}
  \caption{VHDL Context Items}
  \label{tab:vhdl-ctx-items}
\end{table}

\subsubsection{Entity Declaration}
\label{sec:vhdl-entity-declaration}
For a component \code{C}, the template for the entity declaration generated is as follow.
\begin{table}[!htbp]
  \centering
  \begin{tabular}{|p{0.3\textwidth}|p{0.6\textwidth}|}
    \hline
    Source & Destination \\
    \hline
    For component \code{C} & 
                             \begin{VHDLcode}
                               \VHDLENTITY{} C \VHDLIS \\
                               \VHDLPORT{} ( \\
                               \VHDLTab ... Port declarations ... \\
                               ); \\
                               \VHDLTab ... Type declaration ... \\
                               \VHDLEND{} C;
                             \end{VHDLcode} \\
    \hline
  \end{tabular}
  \caption{VHDL Entity Declaration template}
  \label{tab:vhdl-entity-declaration-template}
\end{table}

\paragraph{Port declarations}
The following two ports are generated by default.
\begin{table}[!htbp]
  \centering
  \begin{tabular}{|p{0.3\textwidth}|p{0.6\textwidth}|}
    \hline
    Source & Generated \\
    \hline
    For component \code{C} & 
                             \begin{VHDLcode}
                               \VHDLPORT{} ( \\
                                \VHDLTab clk : \VHDLIN{} std\_logic; \\
                                \VHDLTab reset : \VHDLIN{} std\_logic; \\
                                \VHDLTab ... Other port declarations ... \\
                               );
                             \end{VHDLcode}\\
    \hline
  \end{tabular}
  \caption{VHDL default port declarations}
  \label{tab:vhdl-default-ports}
\end{table}

\subsubsection{Architecture Body}
\label{sec:vhdl-architecture-body}
For a component \code{C}, the template for the architecture body generated is as follow.
\begin{table}[!htbp]
  \centering
  \begin{tabular}{|p{0.3\textwidth}|p{0.6\textwidth}|}
    \hline
    Source & Generated \\
    \hline
    For component \code{C} & 
                             \begin{VHDLcode}
                               \VHDLARCHITECTURE{} behaviour \VHDLOF{} C \VHDLIS \\
                               \VHDLTab ... Signal declaration ... \\
                               \VHDLBEGIN \\
                               \VHDLTab ... Concurrent processes ... \\
                               \VHDLEND{} behaviour;
                             \end{VHDLcode} \\
    \hline
  \end{tabular}
  \caption{VHDL Architecture Body template}
  \label{tab:vhdl-architecture-body-template}
\end{table}


% A corresponding entity declaration and architecture declaration for the component is generated
% \[
% \begin{array}{l}
%   ENTITY ~ C ~ IS \\
%   \ldots \\
%   END~ C;
% \end{array}
% \]

% \[
% \begin{array}{l}
%   ARCHITECTURE ~behaviour~ OF ~C ~IS \\
%     \ldots \\
%  BEGIN\\
%    \ldots\\
%  END
% \end{array}
% \]

% \subsection{Translating VXMI models into VHDL models}
% \label{sec:transl-vxmi-2-vhdl}
% To generate VHDL models from VXMI models is straightforward by pretty printing the VXMI recursively.
% \[
% \begin{array}{lcl}
%   \code{ppDesignFile(} & \widehat{=} & \\
%   \quad \code{DesignUnit1}; & & \code{ppDesignUnit(DesignUnit1)} \\
%   \quad \code{DesignUnit2}; & & \code{ppDesignUnit(DesignUnit2)} \\
%   \quad \ldots & & \ldots\\
%   ) & & \\
%   & & \\
%   \code{ppDesignUnit(} & \widehat{=} & \\
%   \quad \code{ContextItem1} & & \code{ppContextItem(ContextItem1)}\\
%   \quad \code{ContextItem2} & & \code{ppContextItem(ContextItem1)}\\
%   \quad \ldots & & \ldots \\
%   \quad \code{LibraryUnit} & & \code{ppLibraryUnit(LibraryUnit)} \\
%   ) & & \\
%   & & \\
% \end{array}
% \]
               

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "vhdl-user_manual"
%%% End:
