\section{Tasks}
\label{sec:vhdl-tasks}

\subsection{Translating CODA models into VHDL}
\label{sec:transl-coda-2-vxmi}

Since VXMI is just a canonical representation of VHDL in XML, we consider the translation from CODA models directly to VHDL.

For a component \code{C}, its corresponding model contains two design units.
\begin{enumerate}
\item The first design unit contains the generated context items and the  entity declaration.
\item The second design unit contains the architecture body of the declared entity.
\end{enumerate}

\subsubsection{Context Items}
\label{sec:vhdl-context-items}

By default, the context items are generated for each component can be seen in Table \ref{tab:vhdl-ctx-items}.
\begin{table}[!htbp]
  \centering
  \begin{tabular}{|p{0.3\textwidth}|p{0.6\textwidth}|}
    \hline
    Source & Generated \\
    \hline
    For component \code{C} & 
                                  \begin{VHDLcode}
                                    \VHDLLIBRARY{} ieee;\\
                                    \VHDLUSE{} ieee.std\_logic\_1164.all;\\
                                    \VHDLUSE{} ieee.std\_logic\_unsigned.all;
                                  \end{VHDLcode} \\
    \hline
  \end{tabular}
  \caption{VHDL Context Items}
  \label{tab:vhdl-ctx-items}
\end{table}

\subsubsection{Entity Declaration}
\label{sec:vhdl-entity-declaration}
For a component \code{C}, the template for the entity declaration generated is as in Table \ref{tab:vhdl-entity-declaration-template}.
\begin{table}[!htbp]
  \centering
  \begin{tabular}{|p{0.3\textwidth}|p{0.6\textwidth}|}
    \hline
    Source & Destination \\
    \hline
    For component \code{C} & 
                             \begin{VHDLcode}
                               \VHDLENTITY{} C \VHDLIS \\
                               \VHDLPORT{} ( \\
                               \VHDLTab ... Port declarations ... \\
                               ); \\
                               \VHDLTab ... Type declarations ... \\
                               \VHDLEND{} C;
                             \end{VHDLcode} \\
    \hline
  \end{tabular}
  \caption{VHDL Entity Declaration template}
  \label{tab:vhdl-entity-declaration-template}
\end{table}

\paragraph{Port declarations}
For each component \code{C}, the two input ports \code{clk} and \code{reset} are generated by default.  The input/output connectors to the component result in the input/output port declarations accordingly (see Table~\ref{tab:vhdl-port-declarations}).
\begin{table}[!htbp]
  \begin{tabular}{|p{0.3\textwidth}|p{0.6\textwidth}|}
    \hline
    Source & Generated \\
    \hline
    For component \code{C} & 
                             \begin{VHDLcode}
                               \VHDLPORT{} ( \\
                                \VHDLTab clk \VHDLColon{} \VHDLIN{} std\_logic; \\
                                \VHDLTab reset \VHDLColon{} \VHDLIN{} std\_logic; \\
                                \VHDLTab ... Other port declarations ... \\
                                \VHDLTab ... (see below) ... \\
                               );
                             \end{VHDLcode}\\
    \hline
    For \code{C}'s input connector \code{input} of type \code{inputType} &
                                                                            \begin{VHDLcode}
                                                                              \VHDLTab input \VHDLColon{} \VHDLIN{} inputType\VHDLSemicolon
                                                                            \end{VHDLcode}\\
    \hline
    For \code{C}'s output connector \code{output} of type \code{outputType} &
                                                                            \begin{VHDLcode}
                                                                              \VHDLTab output \VHDLColon{} \VHDLOUT{} outputType\VHDLSemicolon
                                                                            \end{VHDLcode}\\
   \hline
  \end{tabular}
  \caption{VHDL Port Declarations}
  \label{tab:vhdl-port-declarations}
\end{table}

\paragraph{Type declarations} For each component \code{C}, the enumeration type \code{BOOL}. For each enumerated user-defined types that is ``used'' for component \code{C}, its definition is generated as type declarations for the entity. An example of a used type is the type of an input or output connector.  For each state-machine of \code{C}, an enumerated type is generated accordingly. For nested state-machine, the \code{NULL} element is also generated.  The type declarations can be seen in Table~\ref{tab:vhdl-type-declarations}.
\begin{table}[!htbp]
  \centering
  \begin{tabular}{|p{0.3\textwidth}|p{0.6\textwidth}|}
    \hline
    Source & Generated \\
    \hline
    For component \code{C} & 
                             \begin{VHDLcode}
                               \VHDLTYPE{} BOOL \VHDLIS{} \VHDLOpenBracket TRUE\VHDLComma FALSE\VHDLCloseBracket\VHDLSemicolon
                             \end{VHDLcode}\\
    \hline
    For a enumerated used-type \code{TYPE} with axiom \code{partition(TYPE, \{ELEM1\}, \{ELEM2\}, ..., \{ELEMn\})} &
                             \begin{VHDLcode}
                               \VHDLTYPE{} TYPE \VHDLIS{} \VHDLOpenBracket ELEM1\VHDLComma ELEM2,..., ELEMn\VHDLCloseBracket\VHDLSemicolon
                             \end{VHDLcode}\\
    \hline
    For \emph{top-level} state-machine \code{SM} with states \code{S1}, \code{S2}, ..., \code{Sn} &
                                                                                             \begin{VHDLcode}
                                                                                               \VHDLTYPE{} SM \VHDLIS{} \VHDLOpenBracket S1\VHDLComma S2,..., Sn\VHDLCloseBracket\VHDLSemicolon                                           
                                                                                             \end{VHDLcode}\\
    \hline
    For \emph{nested} state-machine \code{SM} with states \code{S1}, \code{S2}, ..., \code{Sn} &
                                                                                             \begin{VHDLcode}
                                                                                               \VHDLTYPE{} SM \VHDLIS{} \VHDLOpenBracket SM\_NULL\VHDLComma{} S1\VHDLComma{} S2,..., Sn\VHDLCloseBracket\VHDLSemicolon                                           
                                                                                             \end{VHDLcode}\\
    \hline
  \end{tabular}
  \caption{VHDL Type Declarations}
  \label{tab:vhdl-type-declarations}
\end{table}

\subsubsection{Architecture Body}
\label{sec:vhdl-architecture-body}
For a component \code{C}, the template for the architecture body generated is as in Table \ref{tab:vhdl-architecture-body-template}.
\begin{table}[!htbp]
  \centering
  \begin{tabular}{|p{0.3\textwidth}|p{0.6\textwidth}|}
    \hline
    Source & Generated \\
    \hline
    For component \code{C} & 
                             \begin{VHDLcode}
                               \VHDLARCHITECTURE{} behaviour \VHDLOF{} C \VHDLIS \\
                               \VHDLTab ... Signal declarations ... \\
                               \VHDLBEGIN \\
                               \VHDLTab ... Concurrent processes ... \\
                               \VHDLEND{} behaviour;
                             \end{VHDLcode} \\
    \hline
  \end{tabular}
  \caption{VHDL Architecture Body template}
  \label{tab:vhdl-architecture-body-template}
\end{table}

\paragraph{Clock Process} For a component \code{C}, a clock process is generated using the template in Table \ref{tab:vhdl-clock-process-template}.
\begin{table}[!htbp]
  \centering
  \begin{tabular}{|p{0.3\textwidth}|p{0.6\textwidth}|}
    \hline
    Source & Generated \\
    \hline
    For component \code{C} & 
                             \begin{VHDLcode}
                               \VHDLPROCESS{} \VHDLOpenBracket clk\VHDLComma{} reset\VHDLCloseBracket \\
                               \VHDLBEGIN \\
                               \VHDLTab \VHDLIF{} \VHDLOpenBracket reset = '1'\VHDLCloseBracket{} \VHDLTHEN \\
                               \VHDLTab \VHDLTab ... Initialisation ... \\
                               \VHDLTab \VHDLELSIF{} \VHDLOpenBracket raising\_edge(clk)\VHDLCloseBracket{} \VHDLTHEN \\
                               \VHDLTab \VHDLTab ... Next state assignments ... \\
                               \VHDLTab \VHDLEND \VHDLIF\VHDLSemicolon\\
                               \VHDLEND \VHDLPROCESS\VHDLSemicolon
                             \end{VHDLcode}\\
    \hline
  \end{tabular}
  \caption{VHDL Clock process template}
  \label{tab:vhdl-clock-process-template}
\end{table}

\paragraph{Component Variables as Signal Declarations}
For each variable \code{var} of type \code{varType} of a component \code{C}, an interface signal declaration is created as seen in Table \ref{tab:vhdl-components-variables-signal-declarations}.
\begin{table}[!htbp]
  \centering
  \begin{tabular}{|p{0.3\textwidth}|p{0.6\textwidth}|}
    \hline
    Source & Generated \\
    \hline
    For each variable \code{var} of type \code{varType} of component \code{C} &
                                                                                 \begin{VHDLcode}
                                                                                   \VHDLSIGNAL{} var \VHDLColon{} varType\VHDLSemicolon
                                                                                 \end{VHDLcode}\\
    \hline
  \end{tabular}
  \caption{VHDL Component Variables as Signal Declarations}
  \label{tab:vhdl-components-variables-signal-declarations}
\end{table}

\paragraph{State-machine Variables as Signal Declarations}
For each state-machine \code{SM} of a component \code{C}, two signals are declared for the current and the next values of the state-machine (see Table \ref{tab:vhdl-sm-variables-signal-declarations}).
\begin{table}[!htbp]
  \centering
  \begin{tabular}{|p{0.3\textwidth}|p{0.6\textwidth}|}
    \hline
    Source & Generated \\
    \hline
    For each state-machine \code{SM} of component \code{C} &
                                                                                 \begin{VHDLcode}
                                                                                   \VHDLSIGNAL{} current\_SM \VHDLColon{} SM\VHDLSemicolon\\
                                                                                   \VHDLSIGNAL{} next\_SM \VHDLColon{} SM\VHDLSemicolon
                                                                                 \end{VHDLcode}\\
    \hline
  \end{tabular}
  \caption{VHDL State-machine Variables as Signal Declarations}
  \label{tab:vhdl-sm-variables-signal-declarations}
\end{table}

\paragraph{Top-level State-machines as Process Declarations}
For each top-level state-machine \code{SM} of the component \code{C}, a process declaration is created. The sensitivity list of the process consists of the current state of the state-machine and the signals corresponding to input connectors of component \code{C}.
\begin{table}[!htbp]
  \centering
  \begin{tabular}{|p{0.3\textwidth}|p{0.6\textwidth}|}
    \hline
    Source & Generated \\
    \hline
    Each top-level state-machine \code{SM} of the component \code{C} with input connectors \code{C1}, \code{C2}, ..., \code{Cn} &
                                                                                                                                 \begin{VHDLcode}
                                                                                                                                    \VHDLPROCESS{} \VHDLOpenBracket current\_SM\VHDLComma{} C1\VHDLComma{} C2\VHDLComma{} ... \VHDLComma{} Cn\VHDLCloseBracket\\
                                                                                                                                    \VHDLBEGIN{}\\
                                                                                                                                    \VHDLTab ... Process body ...\\
                                                                                                                                    \VHDLEND\\
\end{VHDLcode}\\
    \hline
  \end{tabular}
  \caption{VHDL Top-level State-machine as Process Declarations Template}
  \label{tab:vhdl-top-sm-process-declarations-template}
\end{table}

\paragraph{State-machines as case statements}
For each state-machine \code{SM}, a case statement is generated as in Table \ref{tab:vhdl-sm-case-statements}.
\begin{table}[!htbp]
  \centering
  \begin{tabular}{|p{0.3\textwidth}|p{0.6\textwidth}|}
    \hline
    Source & Generated \\
    \hline
    Each state-machine \code{SM} with states \code{S1}, \code{S2}, ... \code{Sn} &
                                                                                   \begin{VHDLcode}
                                                                                     \VHDLCASE{} current\_SM \VHDLIS \\
                                                                                     \VHDLTab \VHDLWHEN{} S1 => \\
                                                                                     \VHDLTab \VHDLTab ... Case alternative body ... \\
                                                                                     \VHDLTab \VHDLWHEN{} S2 => \\
                                                                                     \VHDLTab \VHDLTab ... Case alternative body ...\\
                                                                                     \VHDLTab ... \\
                                                                                     \VHDLTab \VHDLWHEN{} Sn => \\
                                                                                     \VHDLTab \VHDLTab ... Case alternative body ...\\
                                                                                   \end{VHDLcode} \\
    \hline
  \end{tabular}
  \caption{VHDL State-machine as Case Statements}
  \label{tab:vhdl-sm-case-statements}
\end{table}
If \code{SM} is a top-level machine, the case statement is attached to the body of the process corresponding to \code{SM}.  In the case where \code{SM} is a nested state-machine within a state \code{S} of another state-machine. The case statement is attached to the case alternative corresponding to \code{S}, i.e. the case alternative body of \code{\VHDLWHEN{} S =>}.

\paragraph{State-machine Transitions as Assignments}
A state-machine transition elaborating event \code{e} is translated to an \VHDLIF or \VHDLELSIF clause.  Assume that the source of the transition is a state \code{S} and the target of the transition is a state \code{T}.  The generated statement (i.e., \VHDLIF or \VHDLELSIF clause) is attached to the case alternative corresponding to the \code{S} state.  The guards and actions of the transition is added accordingly.  We consider the entering states and leaving states of the transition to translate them into assignments of the next state-machine value accordingly.
\begin{table}[!htbp]
  \centering
  \begin{tabular}{|p{0.3\textwidth}|p{0.6\textwidth}|}
    \hline
    Source & Generated \\
    \hline
    A transition elaborating event \code{e} with guard \code{G} and action \code{A}&
                                              \begin{VHDLcode}
                                                \VHDLIF/\VHDLELSIF{} (G) \VHDLTHEN \\
                                                \VHDLTab A
                                              \end{VHDLcode}\\
    \hline
    Each \emph{entering} state \code{ES} (of state-machine \code{TSM}) of the transition &
                                                                                    \begin{VHDLcode}
                                                                                      \VHDLTab next\_TSM <= ES
                                                                                    \end{VHDLcode}\\
    \hline
    Each \emph{leaving} state \code{LS} (of state-machine \code{SSM}) of the transition &
                                                                                    \begin{VHDLcode}
                                                                                      \VHDLTab next\_SSM <= SSM\_NULL
                                                                                    \end{VHDLcode}\\
    \hline
  \end{tabular}
  \caption{VHDL State-machine Transitions as Assignments}
  \label{tab:vhdl-sm-transitions-assignments}
\end{table}

\paragraph{Component Transitions as Assignments}
For each component transition elaborating event \code{e}, its guards and actions are translated accordingly. If the same event is elaborated by some state-machine transition, the component transition guards and actions is appended to the translation of the state-machine transition (as showed previously).  A port-send operation (to a connector \code{C} with value \code{v}) is translated to an assignment.
\begin{table}[!htbp]
  \centering
  \begin{tabular}{|p{0.3\textwidth}|p{0.6\textwidth}|}
    \hline
    Source & Generated \\
    \hline
    Each component transition with guard \code{G} and action \code{A} &
                                              \begin{VHDLcode}
                                                \VHDLIF/\VHDLELSIF{} (G) \VHDLTHEN \\
                                                \VHDLTab A
                                              \end{VHDLcode}\\
    \hline
    Each port-send operation to a connector \code{C} with value \code{v} &
                                                                           \begin{VHDLcode}
                                                                             \VHDLTab C <= v
                                                                           \end{VHDLcode}\\
    \hline
  \end{tabular}
  \caption{VHDL Component Transitions as Assignments}
  \label{tab:vhdl-component-transitions-assignments}
\end{table}

\paragraph{Component Port Wakes as Process/Assignments}
For each Port Wake event, if the same event is elaborated by some state-machine transition, it will be translated by appending the guards, actions, etc. to the state-machine transition's translation.  Otherwise, a new process is create for the Port Wake event.  A Port Wake event contributes to the \VHDLIF or \VHDLELSIF clause: both in the condition and the assignment part. The port wake receives is used to rewrite the translation of the guards and actions.  In the below, we use the notation \code{[c := v] E} to denote the formula obtain by replacing \code{c} with \code{v}.
\begin{table}[!htbp]
  \centering
  \begin{tabular}{|p{0.3\textwidth}|p{0.6\textwidth}|}
    \hline
    Source & Generated \\
    \hline
    The guard \code{G} of a Port Wake event & Boolean expression \code{[c := v]G} \\
    \hline
    The action \code{A} of a Port Wake event & Assignment \code{[c := v] A} \\
    \hline
    The port sends of a Port Wake event & Assignment to the corresponding connector with rewriting \code{[c := v]}
  \end{tabular}
  \caption{VHDL Component Port Wakes as Process/Assignments}
  \label{tab:vhdl-port-wakes-process-assignment}
\end{table}

\paragraph{State-machine Initial Transition as Initial Assignments}
For each intial transition (transition start from an \emph{Initial} state), assignments to the relevant state-machine variables is executed with the clock is reset, (the \VHDLIF{} clause in the clock process).
\begin{table}[!htbp]
  \centering
  \begin{tabular}{|p{0.3\textwidth}|p{0.6\textwidth}|}
    \hline
    Source & Generated \\
    \hline
    For each state \code{S} of state-machine \code{SM} that the initial transition enter (note that this included nested states) & \begin{VHDLcode}
  current\_SM <= S                                                                                               
                                                                                                                                 \end{VHDLcode}\\
    \hline
  \end{tabular}
  \caption{VHDL State-machine Initial Transition as Initial Assignments}
  \label{tab:vhdl-init-transition-assignments}
\end{table}

\paragraph{State-machine as State-update Assignment}
For each state-machine \code{SM} an state-update assignment is created as follows in the \VHDLELSIF clause of the clock process.
\begin{table}[!htbp]
  \centering
  \begin{tabular}{|p{0.3\textwidth}|p{0.6\textwidth}|}
    \hline
    Source & Generated \\
    \hline
    For each state state-machine \code{SM} & \begin{VHDLcode}
  current\_SM <= next\_SM                                                                                      \end{VHDLcode} is created in the \VHDLELSIF{} clause of the clock process.\\
    \hline
  \end{tabular}
  \caption{VHDL State-machine Initial Transition as Initial Assignments}
  \label{tab:vhdl-init-transition-assignments}
\end{table}

% A corresponding entity declaration and architecture declaration for the component is generated
% \[
% \begin{array}{l}
%   ENTITY ~ C ~ IS \\
%   \ldots \\
%   END~ C;
% \end{array}
% \]

% \[
% \begin{array}{l}
%   ARCHITECTURE ~behaviour~ OF ~C ~IS \\
%     \ldots \\
%  BEGIN\\
%    \ldots\\
%  END
% \end{array}
% \]

% \subsection{Translating VXMI models into VHDL models}
% \label{sec:transl-vxmi-2-vhdl}
% To generate VHDL models from VXMI models is straightforward by pretty printing the VXMI recursively.
% \[
% \begin{array}{lcl}
%   \code{ppDesignFile(} & \widehat{=} & \\
%   \quad \code{DesignUnit1}; & & \code{ppDesignUnit(DesignUnit1)} \\
%   \quad \code{DesignUnit2}; & & \code{ppDesignUnit(DesignUnit2)} \\
%   \quad \ldots & & \ldots\\
%   ) & & \\
%   & & \\
%   \code{ppDesignUnit(} & \widehat{=} & \\
%   \quad \code{ContextItem1} & & \code{ppContextItem(ContextItem1)}\\
%   \quad \code{ContextItem2} & & \code{ppContextItem(ContextItem1)}\\
%   \quad \ldots & & \ldots \\
%   \quad \code{LibraryUnit} & & \code{ppLibraryUnit(LibraryUnit)} \\
%   ) & & \\
%   & & \\
% \end{array}
% \]
               

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "vhdl-user_manual"
%%% End:
